% Definiujemy modu³ zawieraj¹cy rozwi¹zanie.
% Nale¿y zmieniæ nazwê modu³u na {imie}_{nazwisko} gdzie za
% {imie} i {nazwisko} nale¿y podstawiæ odpowiednio swoje imiê
% i nazwisko bez wielkich liter oraz znaków diakrytycznych
%:- module(oskar_sobczyk, [resolve/4, prove/2]).

% definiujemy operatory ~/1 oraz v/2
:- op(200, fx, ~).
:- op(500, xfy, v).

% Szukanie rezolwenty.
% UWAGA: to nie jest jeszcze rozwi¹zanie; nale¿y zmieniæ definicjê
% tego predykatu
%resolve(q, p v q, ~q v r, r v p).

% G³ówny predykat rozwi¹zuj¹cy zadanie.
% UWAGA: to nie jest jeszcze rozwi¹zanie; nale¿y zmieniæ jego
% definicjê.



%predykat przeksztalcajacy klauzule na liste jej literalow
kl2list(H v T,[H|X]):-kl2list(T,X),!.
kl2list(X,[X]).

%predykat zamieniajacy liste klauzul na liste list
tolist([],[]).

tolist([H | T],[H2sort | T1]):-
	kl2list(H,H1),
	sort(H1,H2sort),
	tolist(T,T1).

%zamienia liste list na liste klauzul
list2kl([H | []],H) :- !.
list2kl([H | T],H v X):-list2kl(T,X),!.
list2kl([X],X).
list2kl([],[]) :- !.


%zamienia liste literalow na klauzule
toklauzule([],[]).

toklauzule([H | T],[H1 | T1]):-
	list2kl(H,H1),
	toklauzule(T,T1).

%zwraca zanegowany literal
neg(~A, A):-!.
neg(A, ~A).


%dla kazdego literalu w liscie usuwa jego negacje z listy
delNeg([], []) :- !.

delNeg([Var | T],Out) :-
	neg(Var, NegVar),
	member(NegVar, T),
	!,
	delete(T, NegVar, T1),
	delNeg(T1, Out).

delNeg([Var | T], [Var | T1]) :-
	delNeg(T,T1).

%predykat z polecenia
resolve(Var, PosClause, NegClause, Resolvent):-
    kl2list(PosClause, PosList), %zamiana klauzul na listy
    kl2list(NegClause, NegList),
    delete(PosList,Var, Res1),%usuniecie pozytywnego wystapienia
    neg(Var,NegVar), %zanegowanie zmiennej
    delete(NegList, NegVar, Res2), %usuniecie negatywnego wystapienia
    append(Res1, Res2, List), %polaczenie list
    sort(List, ListSorted), %posortowanie ktore rowniez usuwa duplikaty literalow
    delNeg(ListSorted, ClList),%usuniecie wykluczajacych sie literalow
    list2kl(ClList,Resolvent). % zamiana listy na klauzule

% predykat resolve1 wykorzystywany w predykacie prove. Jest analogiczny
% do resolve z ta roznica ze dziala od razu na klauzulach w postaci
% list
resolve2(Var, Clause1, Clause2, Resolvent) :-
	delete(Clause1, Var, Res1),
	delete(Clause2, Var, Res2),
	neg(Var, NegVar),
	delete(Res1, NegVar, Res3),
	delete(Res2, NegVar, Res4),
	append(Res3, Res4, List),
	sort(List, ListSorted),
	delNeg(ListSorted, Resolvent).




% inicjuje liste w ktorej bedzie trzymane nasze rozwiazanie, wrzuca do
% niej axionimy. Dodatkowo numeruje klauzule
initList(Clauses, ListOfAxionim) :-
		initList(Clauses, ListOfAxionim, [],1).

initList([], ListOfAxionim, ListOfAxionim,_) :- !.
initList([H|T], ListOfAxionim, Acc,Num) :-
	NewNum is Num + 1,
		initList(T, ListOfAxionim, [(H, (axionim), Num) | Acc],NewNum).

prove(Clauses, Out) :-
	initList(Clauses, ListOfAxionim),
	tolist(Clauses, ClausesList), %zamiana listy klauzul na liste list
	length(ListOfAxionim,Num), %obliczenie indexu ostatniej klauzuli
	Index is Num + 1, %nr. od ktorego zaczynamy indeksowanie naszych klauzul
	prove(ClausesList, ListOfAxionim,Index, Proof),
	reverse(Proof, Proof1), %rozwiazanie bedzie w odwrotnej kolejnosci wiec je odwracamy
	writeProof(Proof1,Out), %usuniecie indeksow klauzul z listy
	write(Out),!.

prove([[] | _], X,_, X).

prove([H | T], ListOfAxionim,Num,Proof) :-
	findResolvent([H | T], Res1, Res2, Var), %szukamy 2 klauzul w ktorych mozna zastosowac rezolucje
	resolve2(Var, Res1, Res2, Resolvent), %konstrukcja rezolwenty
	\+ member(Resolvent, [H|T]), %sprawdzenie czy rezolwenta juz nie zostala obliczona
	list2kl(Res1, Res1Cl),
	list2kl(Res2, Res2Cl),
	list2kl(Resolvent, ResolventCl), %zamiana list na klauzule
	findNum(ListOfAxionim,Res1Cl, Num1), %obliczenie indeksow klauzul z ktorych pochodzi rezolwenta
	findNum(ListOfAxionim,Res2Cl, Num2),
	NewAx = [(ResolventCl, (Var,Num1,Num2),Num) | ListOfAxionim ], %dodanie rezolwenty do dowodu
	IncNum is Num + 1,
	prove([Resolvent , H | T], NewAx, IncNum, Proof).


%szuka resolwenty dla zmiennej Var
resolventForVar([Var | _],[Clause |_],Clause, Var) :-
		neg(Var, NegElem),
		member(NegElem, Clause).

resolventForVar([Var | Vars], [_ | Clauses ], Res,Var) :-
	resolventForVar([Var | Vars], Clauses, Res, Var).

resolventForVar([_ | Vars], Clauses, FirstClause, Var) :-
	resolventForVar(Vars, Clauses, FirstClause, Var).


%znajduje kolejne rezolwenty dla kolejnych klauzul
findResolvent([Clause | Clauses], Clause, Resolvent, Var) :-
	resolventForVar(Clause, Clauses, Resolvent,Var).

findResolvent([ _ | Clauses], Res1, Res2, Var) :-
	findResolvent(Clauses, Res1, Res2, Var).


%znajduje numer klauzuli
findNum([(Clause,_,Nmbr) | _] ,Clause, Nmbr) :- !.
findNum([(_,_,_) | T] ,Clause, Nmbr) :- findNum(T, Clause, Nmbr).

writeProof([],[]).
writeProof([(Clause, Poch, _) | T],[(Clause, (Poch))| Steps]) :-
	writeProof(T,Steps).


